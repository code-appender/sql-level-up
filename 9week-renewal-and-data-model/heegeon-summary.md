# 갱신과 데이터 모델

## 9.1 갱신은 효율적으로

### 9.1.1 NULL 채우기
갱신 대상이 되는 레코드에 val 필드를 계산하여 NULL을 채울 때, 
대부분 커서 또는 호스트 언어로 레코드를 하나씩 읽고 반복문을 돌리는 반복계를 사용한다.

이외로는 서브쿼리를 이용하는 방법이 있다.
서브쿼리를 이용하면 데이터의 양이 적을 때는 seq scan이 수행되지만, 데이터양이 늘어나면 기본키 인덱스 스캔이 이루어져
반복계에 비해 성능이 높아질 수 있다.

## 9.2 레코드에서 필드로의 갱신
레코드에서 필드로 테이블을 갱신할 때에는 두 가지 방법을 사용할 수 있다.

### 9.2.1 필드를 하나씩 갱신
한 필드씩 갱신하는 상관 서브쿼리를 사용하는 기본적인 방법이다.

하지만 n개의 필드를 위해 n개의 상관서브쿼리를 사용해야 하기 때문에 성능적으로 좋지 못하다.

이 때, 사용할 수 있는 방법은 다중 필드 할당이다.

### 9.2.2 다중 필드 할당
```sql
UPDATE 테이블A
SET (컬럼a, 컬럼b, 컬럼c)
    = (서브쿼리)
FROM 테이블B
WHERE A.id = B.id
```
이 방식을 사용하면 한 번의 스캔으로 여러 필드를 갱신할 수 있다.

### 9.2.3 NOT NULL 제약이 걸린 경우
갱신 과정에서 NOT NULL 제약을 마주치면 어떻게 해야 할까?

이에 대응하는 방법으로는 COALESCE 함수를 사용하는 방법과 MERGE를 사용하는 방법이 있다.
이 중 MERGE를 사용하면 조건에 상관없이 풀 스캔 1회 + 정렬 1회가 필요한데, 갱신할 필드가 많아져도 이 과정을 유지하기 때문에 
성능이 일정하다는 장점이 있다.

## 9.3 필드에서 레코드로의 갱신
이는 CASE WHEN으로 간단하고 성능이 뛰어나게 해결할 수 있다.

### 9.4 같은 테이블의 다른 레코드로 갱신
갱신 대상이 되는 레코드가 같은 테이블에 있는 경우, 서브쿼리를 사용하는 방법과 윈도우 함수를 사용하는 방법이 있다.

윈도우 함수를 사용하면 스캔 횟수가 1회이고, 상관 서브쿼리를 사용하면 스캔 횟수가 2회이기 때문에 윈도우 함수를 사용하는 것이 좋다.

### 9.4.1 갱신이 초래하는 트레이드오프
만약 여러 테이블에 존재하는 특정 레코드들간의 관계를 계산하고자 할 때, 두 가지 방법을 사용할 수 있다.

하나는 Join을 사용해 계산하는 방법이고 다른 하나는 모델을 갱신하는 것이다.

Join을 사용하면 sql에 의지하여 간단하게 해결할 수 있다. 하지만 모델을 갱신하면 후에 간단한 조회 쿼리 하나만으로도 원하는 결과를 얻을 수 있다.
또한, 결합과 같은 불안정 요소를 제거할 수 있다.

하지만 모델을 갱신하면 UPDATE가 지속적으로 발생하여 갱신비용이 높아질 수가 있고 동기화 문제를 해결해야 한다.

두 방식 중 적절한 방식을 선택하기 위해서는 각 방식의 장단점을 고려하여 선택해야 한다.
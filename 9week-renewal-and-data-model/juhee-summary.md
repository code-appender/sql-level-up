# 9장 : 갱신과 데이터 모델

## 26장 : 갱신은 효율적으로

1. Null 채우기

반복계를 사용하지 말것

상관 서브쿼리를 사용하는것이 낫다.

### 27장 : 레코드에서 필드로의 갱신

1. null채우기
    1. 필드를 하나씩 갱신 (성능 👎🏼)
    2. 다중 필드 할당
        1. 트레이드 오프가 있음(정렬을 해야한다.)
2. Not Null제약이 걸려있는 경우
    1. update 구문 사용
    2. merge 구문 사용
        1. 상관 서브쿼리를 여러개 사용할 때와 달리 성능이 악화될 위험이 없다.

## 28장 : 필드에서 레코드로 변경

## 29장 : 같은 테이블의 다른 레코드로 갱신

1. 상관 서브쿼리 사용
    1. SIGN 부호 조사 함수를 활용하여 진행할 수 있음
2. 윈도우 함수
    1. PARTITION BY를 활용하여 진행할 수 있음
3. Insert vs update
    1. insert가 고속처리에 유리함, 또한 자시참조를 허가하지 않는 데이터 베이스에서도 사용할 수 있음, 단점은 같은 크기와 구조를 가진 데이터를 두개 만들어야 함.

## 30장 : 갱신이 초래하는 트레이드 오프

1. SQL을 사용하는 방법
2. 모델 갱신을 사용하는 방법

⇒ 모델을 잘 만들어야 한다!

## 31장 : 모델 갱신의 주의점

1. 높아지는 갱신 비용
    1. 검색 부하를 갱신 부하로 미루는 꼴
2. 갱신 까지의 시간 랙 발생
    1. 성능과 실시간성의 트레이드 오프 발생
3. 모델 갱신 비용 발생
    1. 이후에 큰 문제를 일으키는 핫스팟을 잘 고려해야함

## 32장 : 시야 협착 : 관련 문제

넓은 시야를 가져야 한다.

## 33장 : 데이터 모델을 지배하는 자가 시스템을 지배한다.

테이블은 처음 설계가 매우 중요하고

데이터 모델이 코드를 결정하지 코드가 데이터 모델을 결정하지 않는다.
# 인덱스 사용

## 10.1 인덱스와 B-tree
### 10.1.1 만능형: B-tree
B-tree는 데이터를 트리 구조로 저장하는 형태의 인덱스이며 균현잡힌 뛰어난 범용성을 인정받아 가장 많이 사용되는 인덱스 형태이다.

이와 비슷하게 B+tree가 있다. 
B+tree는 B-tree의 변형으로, B-tree의 단점을 보완한 형태이다.

트리의 리프 노드에만 키값을 저장하고 루트와 리프의 거리를 최소화하여 빠른 검색을 가능하게 한다.
또한, 트리의 깊이도 대개 3-4 수준으로 일정하게 유지하며 데이터가 정렬 상태를 유지한다.

이를 잘 활용하면 집약 함수와 같은 기능을 사용하지 않고 정렬을 넘길 수 있다.

## 10.2 인덱스를 잘 활용하려면

### 10.2.1 카디널리티와 선택률
카디널리티는 값의 균형을 나타내는 개념이다. 

카디널리티가 가장 높은 필드는 모든 레코드에 다른 값이 들어가있는 유일 키 필드이며, 
반대로 모든 레코드에 같은 값이 들어가 있다면 카디널리티가 가장 낮은 필드이다.

평균적으로 카디널리티가 5% 이하인 필드에는 인덱스를 작성할 가치가 있다. 최근 DBMS에서는 대체로 5%~10%를 기준으로 삼는다.

## 10.3 인덱스로 성능 향상이 어려운 경우
인덱스 설계는 테이블 정의와 SQL만 봐서는 판단하기 어렵다.

특정 SQL에 적절한 인덱스를 작성하려면 SQL의 검색 조건과 결합 조건을 바탕으로 데이터를 효율적으로 압축할 수 있는 조건을
찾아야 하는데 이러한 조건이 존재하지 않는 경우가 있을 수 있다.

### 10.3.1 압축 조건이 존재하지 않는 경우
```sql
SELECT * FROM {테이블명} ;
```
위와 같이 sql 구문에 데이터를 압축하는 조건이 없는 경우 인덱스를 사용할 수 있는 필드도 없어진다.

### 10.3.2 레코드를 제대로 압축하지 못하는 경우
```sql
SELECT * FROM {테이블명} WHERE {조건} ;
```
위와 같은 sql 구문에서 where절로 선택되는 레코드의 수가 너무 많은 경우 인덱스를 적용할 수 없다.

즉, 인덱스가 제대로 작동하려면 "레코드를 크게 압축할 수 있는 검색 조건"이 필요하다.

### 10.3.3 인덱스를 사용하지 않는 경우
압축 검색 조건이 있음에도 인덱스를 사용할 수 없는 타입이 있을 수 있다.

예를 들어, LIKE 연산자를 사용하는 경우 `LIKE 'A%'`와 같은 경우에는 인덱스를 사용할 수 있지만 `LIKE '%A'`와 같은 경우에는 인덱스를 사용할 수 없다.

### 10.3.4 색인 필드로 연산하는 경우
```sql
SELECT * FROM {테이블명} WHERE {색인 필드} + 1 > {값} ;
```
이처럼 색인 필드로 연산을 하는 경우에는 인덱스를 사용할 수 없다.
하지만 이 경우에는 다음과 같이 변경하여 인덱스를 사용할 수 있다.
```sql
SELECT * FROM {테이블명} WHERE {색인 필드} > {값} - 1 ;
```

검색 조건의 우변에 식을 사용하면 인덱스가 사용된다.

이외에도 IS NULL을 사용하는 경우, 부정형을 사용하는 경우에도 인덱스를 사용할 수 없다.

## 10.4 인덱스를 사용할 수 없는 경우 대처법
### 10.4.1 외부 설정으로 처리
인덱스를 사용하지 못하는 경우 애시당초 인덱스가 필요한 쿼리가 실행되지 않도록 UI를 수정하기도 한다.

### 10.4.2 데이터 마트로 대처
데이터 마트는 특정한 쿼리에서 필요한 데이터만을 저장하는 상대적으로 적은 크기의 테이블이다.

접근 대상의 크기를 작게하여 I/O 양을 줄이는 것이 데이터 마트의 목적이다.

### 10.4.3 데이터 마트 주의점
데이터 마트를 사용하면 데이터 신선도를 주의해아 한다.
원래 테이블의 복제본이기 때문에 원본 테이블이 갱신되면 데이터 마트도 갱신되어야 할 필요가 있다.
이 갱신의 주기과 데이터의 신선도를 고려하여 데이터 마트를 사용해야 한다.

또한, 데이터 마트는 테이블의 크기를 줄여 성능을 향상하는 목적인데 이 테이블의 크기가 충분히 작아지지 않는 경우
데이터 마트를 이용할 이유가 없다.

## 10.5 인덱스 온리 스캔으로 대처
목적 필드를 인덱스로 만들어서 인덱스만으로 검색하는 방법이다.

하지만 인덱스 온리 스캔은 DBMS에 따라 사용할 수 없는 경우도 있고 갱신 오버헤드가 커지며 정기적인 인덱스 리빌딩이 필요하고
SQL 구문에 새로운 필드가 추가되면 인덱스를 재작성해야 하는 등의 단점이 있다.
# 10장 : 인덱스 사용

## 34장 :  인덱스와 B-tree

### 만능형 : B-tree

데이터를 트리구조로 저장하는 형태의 인덱스

대부분의 데이터 베이스에서는 이 B-Tree를 사용하고

특히 B-Tree가 아닌 수정된 버전인 B+tree를 채택한다.

B+tree가 더 좋은 이유는 루트와 리프의 거리를 가능한 일정하게 유지하려 하여 균형이 잘 잡혀 검색 성능이 안정적이다. 또한 트리의 깊이도 대게 2-4수준으로 일정하고 정렬 상태를 유지하여 이분탐색을 통해 검색 비용을 줄일 수 있다. 이를 통해 집약 함수 등에서 요구되는 정렬을 하지 않은 채 넘어갈 수도 있다.

### 기타 인덱스

비트맵 인덱스  : 비트 프롤그로 변환해서 저장하는 형태의 인덱스 ( 카디널리티가 낮은 필드에 대해 효과를 발휘한다)

해시 인덱스 : 키를 해시 분산해서 등가 검색을 고속으로 실행하고자 만들어진 인덱스 이다 .

하지만 등가 검색 외에는 효과가 거의 없고 범위 검색을 할 수 없다는 점에 거의 사용되지 않고 지원하는 구현도 일부에 불가하다.

## 35장 : 인덱스를 잘 활용하려면

B+tree 인덱스의 장점은 키값 사이에 검색 속도의 분균형이 거의 없어 데이터 양이 증가해도 속도가 갑자기 악화하는 일이 없다. 또한 등호 뿐만 아니라 부등호를 사용한 검색 조건에 사용할 수 있다.

1. 카디널리티와 선택률
    1. 카디널리티는 높은것이 좋다 (값의 종류가 많아야 인덱스가 효율적으로 동작한다)
    2. 선택률은 특정 필드값을 지정했을대 테이블 전체에서 몇개의 레코드가 선택 되는 지를 타나내는 개념이다

   카디널리티가 낮은 인덱스를 선택하는 경우는 값의 중복이 많기 떄문에 특정 값을 찾는데 효과적이지 않을 수 있습니다. (즉 거의 테이블 전체를 스캔하는것과 유사하게 진행될 수 있습니다)

   B+tree의 인덱스를 확인하는 경우 값의중복이 많다면 일치하는 값들이 많아지게 되고 오히려 인덱스를 사용한는것이 비효율적일수 있습니다. 이런 경우 옵티마이저가 인덱스를 전체 테이블을 스캔하게 될 수 있고 인덱스를 사용하는것보다 더 많은 I/O작업이 일어날 수 있어 성능이 떨어집니다.

   또한 B+tree내에서 동일한 값을 찾은후 링크드 리스트로 연결된 노드를 따라가면 계속하여 진행하기에 오히려 비효율적일 수 있습니다. (추가적인 노드 탐색이 많다)

2. 좋은 인덱스
    1. 카디널리티가 높을것! (분산률이 높은것이 좋다)
    2. 선택률이 낮을것 (선택률이 5프로 미만이라면 인덱스를 작성할 가치가 있지만 10프로보다 높다면 테이블 풀스캔이 낫다)

## 36장 : 인덱스로 성능 향상이 어려운 이유

1. 압축 조건이 존재하지 않음
    1. where 절에 아무것도 없는 경우
2. 레코드를 제대로 압축하지 못하는 경우
    1. 선택률이 낮아야 한다.
    2. where 절에 적힌걸로 선택되는 데이터가 너무 높다면 의미가 없다.
    3. 입력 매개변수에 따라 선택률이 변동하는 경우
        1. 매개변수에 의해 선택률이 변하는 경우가 있다.
3. 인덱스를 사용하지 않는 검색 조건
    1. like를 사용하는 경우와 같이

       BTree의 특징상 자식 노드의 데이터들은 노드 데이터를 기준으로 왼쪽에서 오른쪽으로 작은값 큰값이 정렬되어있습니다.
       즉 인덱스의 작동방식과 특성에 의헤 전방 일치에만 인덱스를 적용할 수 있습니다.

       따라서 특정 값으로 시작하는 데이터를 찾는 것은 쉽지만, 특정 값으로 끝나는 데이터를 찾는 것은 어려워집니다. '%' 와일드카드가 앞에 위치하는 경우에는 검색 대상이 모든 값으로 시작하는 것이기 때문에, B+ 트리에서는 해당 검색을 효율적으로 처리할 수 없습니다. 따라서 Like연산이 사용될때 인덱스를 사용하고자 한다면 전방일치하여 찾는데이터가 많은 경우에만 인덱스를 생성하는 것이 좋습니다.

    2. 색인 필드로 연산하는 경우
    3. IS NULL을 사용하는 경우
    4. 부정형을 사용하는 경우

## 37장 : 인덱스를 사용할 수 없는 경우 대처법

1. 외부 설정으로 처리
    1. UI등을 고려하여 생성될 쿼리를 생각해야한다.
2. 데이터 마트로 대처
    1. 특정한 쿼리에서 필요한 데이터만을 저장하는 상대적으로 작은 크기의 테이블을 의미합니다.
    2. 고려해야할 점
        1. 데이터 신선도 ( 동기 시점의 문제)
        2. 데이터 마트 크기
            1. 잘라낸 데이터의 양이 비슷하다면 굳이 데이터 마트를 할 필요가 엇ㅂ다.
        3. 데이터 마트수
            1. 관리등을 고려하여 너무 지나치게 의존하지 않는것이 좋다.
        4. 배치 윈도우
            1. 어느 정도 규모의 갱신이 발생할 떄 통계정보도 다시 수집해야한다.
    3. 데이터 마트는 주의 하여 사용해야 한다.
3. 인덱스 온리 스캔으로 대처
    1. SQL구문이 접근하려는 대상의 I/O감소를 목적으로 한다.
    2. 인덱스만을 스캔대상으로 하는 검색을 사용할 수 있게 된다.
    3. 주의 사항
        1. DBMS에 따라 사용할 수 없는 경우도 있따.
        2. 한개의 인덱스에 포함할 수 있는 필드수의 제한이 있다.
        3. 갱신 오버헤드가 커진다.
        4. 정기적인 인덱스 리빌드가 필요하다.
        5. SQL구문에 새로운 필드가 추가된다면 사용할 수 없다.
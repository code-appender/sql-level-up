# 10. 인덱스 사용

# 10.1 인덱스와 B-tree

## 10.1.1 B-tree 인덱스

- 트리구조로 데이터를 저장하는 인덱스
- 균형잡힌 범용성으로 가장 많이 사용되는 인덱스
- 트리의 리프노드에만 데이터를 저장하는 개선된 B+tree 버전을 보통 사용한다.

### B+tree 특징

- 루트와 리프의 거리를 가능한 일정하게 유지하여 균형이 잘 잡혀 검색 성능이 안정적이다.
    - 데이터 양이 증가해도 검색 속도가 갑자기 악화되는 일이 없음
- 트리의 깊이도 3-4 수준으로 일정하고, 데이터가 정렬 상태를 유지하여 `이분 탐색`을 통해 검색 비용 절감 가능하다.
- 집약 함수 등에서 요구되는 정렬을 하지 않은 채 실행 가능하다.
- 등호와 부등호를 사용한 검색 조건에서 사용 가능하다.

## 10.1.2 기타 인덱스

- 비트맵 인덱스
    - 데이터를 비트 플래그로 변환해 저장하는 인덱스
    - 카디널리티가 낮은 필드에 대해 효과적
    - 갱신할 때 오버헤드가 커 갱신이 자주 일어나지 않는 BI/DWH 용도로 사용됨
- 해시 인덱스
    - 키를 해시 분산해 등가 검색을 고속 실행하고자 만들어짐
    - 범위 검색을 할 수 없어 거의 사용X

# 10.2 인덱스를 잘 활용하려면

## 10.2.1 카디널리티와 선택률

### 카디널리티

- 값의 균형을 나타내는 개념
- 모든 레코드에 `다른 값`이 들어가있는 유일 키 필드 → 카디널리티 `높음`
- 모든 레코드에 `같은 값`이 들어가 있음 → 카디널리티가 `낮음`

### 선택률

- `특정 필드값을 지정했을 때 테이블 전체에서 몇 개의 레코드가 선택되는지` 나타내는 개념
- 100개 레코드 가진 테이블에서 pk = 1과 같이 등호를 지정하면 1개 레코드 선택됨 → 선택률 1%

### 클러스터링 팩터

- 인덱스의 성능 결정하는 요인
- 저장소에 `같은 값이 어느정도 물리적으로 뭉쳐 존재하는지` 나타내는 지표

- 높을수록 분산됨, 낮을수록 뭉침
- 클러스터링 팩터가 낮을수록 접근할 데이터 양이 적어서 좋음

## 10.2.2 인덱스를 사용하는 것이 좋은지 판단하려면

- 카디널리티가 높을 것, 즉 값이 평균치에서 많이 흩어져있을수록 좋음
- 선택률이 낮을 것, 즉 한 번의 선택으로 레코드가 조금만 선택되는 것이 좋음
    - 5 ~ 10% 이하라면 인덱스 작성할 가치가 있고, 선택률이 10% 이상이라면 테이블 풀 스캔을 하는게 더 빠를 수 있다.

# 10.3 인덱스로 성능 향상이 어려운 경우

- 적절한 인덱스를 작성하기 위해 SQL 검색 조건과 결합 조건을 바탕으로 데이터를 효율적으로 압축할 수 있는 조건을 찾아야 한다.
- 이를 위해서는 SQL 구문과 검색 키 필드의 카디널리티를 알아야 한다.

### 예제 테이블

```sql
CREATE TABLE Orders
(order_id CHAR(8) NOT NULL,
shop_id CHAR(4) NOT NULL,
shop_name VARCHAR(256) NOT NULL,
receive_date DATE NOT NULL,
process_flg CHAR(1) NOT NULL,
CONSTRAINT pk_Orders PRIMARY KEY(order_id));
```

## 10.3.1 압축 조건이 존재하지 않음

```sql
SELECT order_id, receive_date
FROM Orders;
```

- 레코드를 압축하는 WHERE 구가 없어 인덱스로 작성할 만한 필드가 없다.

## 10.3.2 레코드를 제대로 압축하지 못하는 경우

```sql
SELECT order_id, receive_date
FROM Orders
WHERE process_flg='5';
```

- process_flg가 5인 레코드가 83%이상이 되는 경우 풀 스캔보다 느려질 가능성 큼 → 인덱스 필요 없다.
- 인덱스가 제대로 작동하려면, `레코드를 크게 압축할 수 있는 검색 조건`이 필요하다.

### 입력 매개변수에 따라 선택률이 변동하는 경우 (1)

```sql
SELECT order_id, receive_date
FROM Orders
WHERE receive_date BETWEEN :start_date AND :end_date;
```

- 입력 범위에 따라 `단기간`이면 검색 범위가 작을 수 있으나 `장기간`일 경우 `검색 범위가 늘어난다.`
- 선택률이 그때그때 다르다.

### 입력 매개변수에 따라 선택률이 변동하는 경우 (2)

```sql
SELECT order_id, receive_date
FROM Orders
WHERE shop_id = :sid;
```

- 상점의 규모에 따라 주문의 개수가 천차만별이므로 선택률도 변동적이다.
- 선택률이 높을 때 인덱스가 사용된다면 오히려 성능 악화가 일어날 수 있다.

## 10.3.3 인덱스를 사용하지 않는 검색 조건

### 중간 일치, 후방 일치의 LIKE 연산자

```sql
SELECT order_id, receive_date
FROM Orders
WHERE shop_name LIKE '%대공원%';
WHERE shop_name LIKE '%대공원';
```

- LIKE 연산자를 사용하는 경우 인덱스는 `전방 일치`(’대공원%’)에만 적용 가능하다.
- 선택률이 낮은 검색 조건이라도 풀 스캔을 사용할 수 밖에 없다.

### 색인 필드로 연산하는 경우

```sql
SELECT order_id, receive_date
FROM Orders
WHERE col_1 > 100/1.1;
```

- 검색 조건의 우변에 식을 사용해야 인덱스 사용 가능하다.
- WHERE col_1 * 1.1 > 100 과 같은 연산에는 인덱스 사용X

### IS NULL 사용하는 경우

```sql
SELECT order_id, receive_date
FROM Orders
WHERE col_1 IS NULL;
```

- `IS NULL을 사용하는 경우`인덱스가 사용되지 않는다.
- 일반적으로 인덱스가 붙은 필드의 데이터에 NULL 존재하지 않기 때문이다.

```sql
SELECT order_id, receive_date
FROM Orders
WHERE LENGTH(col_1)=10;
```

- `인덱스가 붙은 필드에 함수를 사용하는 경우`에도 인덱스가 사용되지 않는다.
- 함수가 사용된 값은 인덱스 내부에 존재하는 값이 아니기 때문이다.

### 부정형을 사용하는 경우

```sql
SELECT *
FROM SomeTable
WHERE col_1 <> 100;
```

# 10.4 인덱스를 사용할 수 없는 경우 대처법

## 10.4.1 외부 설정으로 처리 - 깊고 어두운 강 건너기

### UI 설계로 처리

- 자유롭게 조건을 조합할 수 있게 하여 선택률이 높은 조건을 얻을 수 있도록 입력 제한을 두는 방법

- 어떤 쿼리로 어떤 검색 조건을 만들지는 애플리케이션의 기능과 UI설정에 크게 의존하므로 테이블 정의와 SQL만 보고 인덱스 설계하는 것은 불가능하다.

## 10.4.2 외부 설정을 사용한 대처 방법의 주의점

- 성능과 사용성의 트레이드오프를 통해 타협점을 찾아야 한다.
- 프로젝트 시작하는 단계에서 성능을 고려한 외부 설정이 필요하다.

## 10.4.3 데이터 마트로 처리

- 특정한 쿼리에서 필요한 데이터만 저장하는 상대적으로 작은 크기의 테이블
- 기존 테이블의 일부 필드만 가져와 저장하는 부분 집합
- 접근 대상 테이블의 크기를 작게 해 I/O 양을 줄이는 것이 목적

ex) Orders 테이블의 order_id, receive_date만 저장하는 OrderMart 테이블을 생성해 사용

```sql
SELECT order_id, receive_date
FROM OrderMart;
```

## 10.4.4 데이터 마트를 채택할 시 주의점

- 원본 테이블에서 데이터를 동기화하는 주기에 따라 성능 차이 발생한다.
- 원래 테이블보다 크기를 많이 줄일 수 없다면 의미없음, GROUP BY절을 이용해 집계 후 데이터마트 생성하면 효과적으로 성능 개선 가능
- 기능 요건에 의해 만들어지는 엔티티가 아니고 ER에 등장하지 않아 수가 늘어날수록 관리하기 어려우므로 지나친 의존은 좋지 않음
- 생성할 때 시간이 걸리므로 배치 윈도우를 압박함, 어느정도 규모의 갱신이 발생할 때 통계 정보도 다시 수집해야 함

## 10.4.5 인덱스 온리 스캔으로 대처

- SQL문이 접근하려는 대상의 I/O 감소를 목적으로 한다.
- 2개 필드를 커버하는 `커버링 인덱스`를 생성해 인덱스 온리 스캔을 사용하도록 한다.
- 인덱스는 테이블 필드의 부분 집합만 저장하므로 원래 테이블에 비해 크기가 작아진다.

```sql
CREATE INDEX CoveringIndex ON Orders (order_id, receive_date);
```

### 인덱스 온리 스캔이란?

- 인덱스만으로 필요한 필드를 커버할 수 있는 경우 테이블 접근을 생략하고 인덱스만을 스캔 대상으로 하는 검색이다.

### 레코드를 제대로 압축하지 못하는 경우 `개선`

```sql
CREATE INDEX CoveringIndex ON Orders (process_flg, order_id, receive_date);
```

### 중간 일치, 후방 일치의 LIKE 연산자 `개선`

```sql
CREATE INDEX CoveringIndex ON Orders (shop_name, order_id, receive_date);
```

## 10.4.6 인덱스 온리 스캔의 주의사항

- DBMS에 따라 사용할 수 없는 경우 존재
- 한 개의 인덱스에 포함될 수 있는 필드 수 또는 크기에 제한 있음 -> 인덱스 크기가 너무 커지지 않도록 해야함
- 일반적인 인덱스보다 필드 수가 많아 갱신 오버헤드가 커짐
- 검색 성능 자체가 인덱스의 크기에 의존하므로 **정기적인 크기 모니터링과 리빌드 필요**
- SQL 구문에 새로운 필드 추가되면 사용할 수 없어 유지보수에 약함
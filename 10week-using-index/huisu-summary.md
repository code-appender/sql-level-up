# Using Index

## 인덱스와 B-tree

1. 만능형 B-tree
    - B-tree 인덱스는 데이터를 트리 구조로 저장하는 형태의 인덱스
    - 데이터베이스에서 인덱스라고 말하는 대부분이 해당
    - 검색 알고리즘으로는 뛰어난 성능을 자랑하지는 않음
    - 트리의 리프 노드에 키값만 저장하는 B+tree를 더욱 자주 사용
2. 기타 인덱스
    - 비트맵 인덱스: 데이터를 비트 플래그로 변환해서 저장하는 형태의 인덱스로 카디널리티가 낮은 ㅣㄹ드에 효과 발휘
    - 해시 인덱스: 키를 해시 분한해서 등가 검색을 고속으로 실행하고자 만들어진 인덱스

## 인덱스를 잘 활용하려면

1. 카디널리티와 선택률
    - 모든 레코드에 다른 값이 들어가 있을수록 카디널리티가 높은 필드
    - 선택률: 특정 필드값을 지정했을 때 전체에서 몇 개의 레코드가 선택되는지
    - 클러스터링 팩터: 저장소에 같은 값이 어느 정도 뭉쳐 존재하는지 나타내는 지표
2. 인덱스를 사용하는 것이 좋은지 판단하려면
    - 카디널리티가 높을 것: 값이 평균치에서 많이 흩어져 있을수록 좋은 후보
    - 선택률이 낮을 것: 한 번의 선택으로 레코드가 조금 선택되는 것

## 인덱스로 성능 향상이 어려운 경우

1. 압축 조건이 존재하지 않음
2. 레코드를 제대로 압축하지 못하는 경우
    - 입력 매개변수에 따라 선택률이 변동하는 경우
3. 인덱스를 사용하지 않는 검색 조건
    - 중간 일치, 후방 일치의 LIKE 연산자
    - 색인 필드로 연산하는 경우
    - IS NULL을 사용하는 경우
    - 부정형을 사용하는 경우

## 인덱스를 사용할 수 없는 경우 대처법

1. 외부 설정으로 처리
    - 이러한 쿼리가 실행되지 않게 애플리케이션 UI에서 제한하는 것
    - 사용자는 아무런 필수 조건 없이 내 마음대로 입력하는 것을 좋아하는 경향
    - 성능과 사용성의 트레이드 오프 존재
2. 데이터 마트로 대처
    - 특정한 쿼리군에서 필요한 데이터만을 저장하는 상대적으로 작은 크기의 테이블을 의미
3. 데이터 마트를 채택할 시 주의점
    - 데이터 신선도: 데이터 마트는 원래 테이블의 부분적인 복사라서 동기 사이클을 짧게 유지해야 함
    - 데이터 마트 크기: 원래 테이블에서 크기를 딱히 줄일 수 없다면 무의미
    - 데이터 마트 수: 데이터 마트가 성능 개선에 유용하다고 판단된다고 쓸데없이 좀비 마트들을 대량 생산하지 않을 것
    - 배치 윈도우: 데이터 마트를 만드는 데도 시간이 걸리기 때문에 배치 윈도우 압박
4. 인덱스 온리 스캔으로 대처
    - SQL 구문이 접근하려는 대상의 I/O 감소를 목적으로 함
    - 인덱스를 사용한 고속화 방법
    - SQL 구문에서 필요한 필드를 인덱스만으로 커버할 수 있는 경우에 테이블 접근을 생략하는 기술
5. 인덱스 온리 스캔의 주의사항
    - DBMS에 따라 사용할 수 없는 경우도 존재
    - 한 개의 인덱스에 포함할 수 있는 필드 수에 제한이 있음
    - 갱신 오버 헤드가 커짐
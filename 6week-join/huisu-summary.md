# Join

## 기능적 관점으로 구분하는 결합의 종류

1. 크로스 결합

    ```sql
    SELECT * FROM TABLE_A CROSS JOIN TABLE_B;
    ```

    - 데카르트 곱이라고 불리는 연산으로 가능한 모든 튜플 생성
    - 실무에서 사용되지 않음 → 비용이 많이 들고 필요한 경우가 적어서
    - 결합 조건을 지정하지 않으면 크로스 결합으로 실행
2. 내부 결합

    ```sql
    SELECT * 
    FROM TABLE_A AS A INNER JOIN TABLE_B AS B
    ON A.id = B.id;
    ```

    - 크로스 결합 결과의 일부분 → 데카르트 곱의 부분 집합
    - 크로스 결합에 비용이 많이 들기 때문에 크로스 결합을 구하고 내부 결합을 구하지 않음
    - 상관 서브쿼리로 대체 가능하지만 기본적으로는 결합 사용 권장
3. 외부 결합

    ```sql
    SELECT * 
    FROM TABLE_A AS A INNER JOIN TABLE_B AS B
    ON A.id = B.id;
    ```

    - 데카르트 곱의 부분 집합이 아님
        - 때에 따라서는 데카르트 곱의 부분 집합이 되기도 함
    - 왼쪽 외부 결합, 오른쪽 외부 결합, 완전 외부 결합
    - 왼쪽 외부 결합과 오른쪽 외부 결합은 실질적으로 같은 기능 수행
        - 마스터키가 되는 테이블을 어디에 적는지에 따라 다름
    - 마스터 테이블 쪽에만 존재하는 키가 있을 때 해당 키를 제거하지 않고 결과에 보존
4. 자기 결합
    - 자기 자신과 결합하는 연산
    - 같은 테이블이나 같은 뷰를 사용해 결합
    - 자기 결합을 수행하는 경우 일반적으로 같은 테이블에 다른 별칭을 붙여 여러 테이블인 것처럼 다룸

## 결합 알고리즘과 성능

1. Nested Loop
    - 중첩 반복을 사용하는 알고리즘
    - 세부 처리 과정
        - 결합 대상 테이블에서 레코드를 하나씩 반복하며 스캔
            - 이 테이블을 구동 테이블 (driving table) 혹은 외부 테이블 (outer table)이라고 부름
            - 다른 테이블을 내부 테이블 (inner table)이라고 부름
        - 구동 테이블의 레코드 하나마다 내부 테이블의 레코드를 하나씩 스캔해서 결합 조건에 맞으면 리턴
        - 모든 레코드에 대해 반복
    - 특징
        - 접근되는 레코드 수는 Cardinality(TABLE_A) * Cardinality(TABLE_B)
        - 실행 시간이 레코드 수에 비례
        - 한 단계에서 처리하는 레코드 수가 적어 메모리 소비가 적음
        - 모든 DBMS에서 지원
    - 구동 테이블의 중요성
        - 중첩 반복의 성능을 좋게 하려면 내부 테이블의 결합 키 필드에 인덱스가 존재할 때구동 테이블로 작은 테이블 선택
        - 내부 테이블을 완전히 순환하지 않아도 됨
        - 대응되는 내부 테이블의 레코드를 통해 찾게 되면 접근되는 레코드 수는 Cardinality(TABLE_A) * 2
    - Nested Loop의 단점
        - 결합 키로 내부 테이블에 접근할 때 히트되는 레코드가 만으면 기대하는 만큼의 응답 시간이 나오지 않기도 함
        - 구동 테이블로 큰 테이블을 선택하는 역설적인 방법으로 해결
        - 해시 알고리즘으로 해결
2. Hash
    - Hash의 작동
        - 해시 함수: 입력에 대해 어느 정도 유일성과 균일성을 가진 값을 출력하는 함수
        - 작은 테이블을 스캔하고 결합 키에 해시 함수를 적용해서 해시값으로 변환
        - 큰 테이블을 스캔하고 결합 키가 해시값이 존재하는지 확인
        - 해시 테이블은 워킹 메모리에 저장되기에 작은 테이블에 대해 해시 테이블 생성
    - Hash의 특징
        - 결합 테이블로부터 해시 테이블을 만들어서 활용하기에 Nested Loops에 비해 메모리를 크게 소모
        - 메모리가 부족하면 저장소를 사용하기에 지연 발생
        - 출력되는 해시값은 입력값 순서를 알지 못함
    - Hash가 유용한 경우
        - Nested Loops에서 적절한 구동 테이블이 존재하지 않는 경우
        - Nested Loops에서 내부 테이블에 히트되는 레코드 수가 너무 많은 경우
        - Nested Loops의 내부 테이블에 인덱스가 존재하지 않는 경우
3. Sort Merge
    - Sort Merge의 작동
        - Merge, Merge Join이라고도 부름
        - 결합 대상 테이블들을 각각 결합 키로 정렬하고 일치하는 결합 키를 찾으면 결합
    - Sort Merge의 특징
        - 대상 테이블을 모두 정렬해야 해서 많은 메모리 소비
        - Hash랑 다르게 동치 결합이 아니라 부등호를 사용한 결합에도 사용 가능
            - 부정 조건은 불가능
        - 테이블이 미리 정렬되어 있다면 정렬 생략 가능
    - Sort Merge의 유효성
        - 테이블 정렬을 생략할 수 있는 예외적인 케이스에 고려
4. 의도하지 않은 크로스 결합
    - 삼각 결합

        ```sql
        SELECT A.col_a, B.col_b, C.col_c
        FROM Table_A A
        INNER JOIN Table_B B
        ON A.col_a = B.col_b
        INNER JOIN Table_C C
        ON A.col_a = C.col_c;
        ```

        - A-B, A-C만 결합이 존재하고 B-C는 결합 부재
    - 의도하지 않은 크로스 결합을 회피하는 방법
        - 결합 조건이 존재하지 않는 테이블 사이에 불필요한 결합의 조건을 추가해 주는 것 (B-C)

## 결합이 느리다면

1. 상황에 따른 최적의 알고리즘
    - 소규모-소규모: 어떤 알고리즘이든 사용 가능
    - 소규모-대규모: 소규모 테이블을 구동 테이블로 하면 Nested Loop 그러나 내부 테이블의 결합 대상 레코드가 너무 많다면 Hash도 고려
    - 대규모-대규모: Hash를 사용하고 결합 키로 정렬되어 있다면 Sort Merge 사용
2. 실행 계획 제어
    - 실행 계획을 바꾸는 방법은 DBMS마다 다름
    - 사람의 판단으로 실행 계획을 고정시켜 버리는 것은 DB<S 진화에 역행하는 발상이기도 함
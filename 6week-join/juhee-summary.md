# 6장 : 결합

## 18장 : 기능적 관점으로 구분하는 결합의 종류

기능적 관점

- 크로스 결합
- 내부 결합
- 외부결합

결합 조건

- 등가, 비등가 결합

자기 결합

자연 결합

- 내부 결합이면서 등가 결합
- 결합 조건을 따로 기술하지 않고 암묵적으로 같은 이름의 필드가 결합되는 구조
- but 추천하지 않는다.
    - 확장성이 좋지 않다(필드 이름의 변경하는 경우 등에 대해)
    - 가독성이 좋지 않다(테이블 구조를 파악하지 않는 경우 어렵다)
- using을 사용하는 방법도 있지만 추천하지 않는다. (등가 조건만 표현 가능, 테이블 필드 이름 다른 경우 불가능)

### 크로스 결합

- 실무 사용 기회 없다.
- 데카르트 곱 연산으로 ( 부서 테이블 2개 * 사람 테이블 4명 ⇒ 8개의 조합)을 모두 계산한다.
- 이런 결과가 필요한 경우 없고 비용이 많이 든다.

⇒ 이런일이 왜 발생할까?

테이블 3개이상 연결하는 경우 where 조건에 명시하지 않는 경우가 발생한다. 이런경우 크로스 결합이 되는 경우가 있다.

### 내부 결합

```sql
SELECT E.emp_id, E.emp_name, E.dept_id, D.dept_name
	FROM Employees E INNER JOIN Departments D
		ON E.dept_id = D.dept_id
```

- 가장 많이 사용되는 조합
- 테카르트 곱의 부분집합
- 크로스 결합으로 결과를 내고 결합 조건으로 필터링 하는 것 → 하지만 이렇게 무식하게 하지 않는다.
- 내부 결합과 같은 기능을 하는 상관 서브쿼리
    - dept_id 부서테이블의 기본키로 이를 조건으로 지정하면 레코드가 한개로 한정될것이 보장한다. 따라서  기본키를 사용하면 상관 서브쿼리를 스칼라 서브쿼리(리턴값이 하나의 단일값) 으로 사용할 수 있습니다.

    ```sql
    SELECT E.emp_id, E.emp_name, E.dept_id,
    	(SELECT D.dept_name
    		FROM Departments D
    		WHERE E.dept_id = D.dept_id)AS dept_name --  여기서 한다. 
    FROM Employees E;
    ```


⇒ 기본적으로는 결합을 사용하는 것이 좋고 상관 서브쿼리를 스칼라 서브쿼리로 사용하면 레코드 수만큼 상관 서브쿼리를 실행해 비용이 높아진다.

### 외부 결합

한쪽 테이블의 결과는 조인되지 않아도 모두가지고 있다.

키를 모두 가진 레이아웃의 리포트를 만드는경우 자주 사용한다.

- 오른쪽 외부 결합 (RIGHT OUTER JOIN)
- 왼쪽 외부 결합 (LEFT OUTER JOIN)
- 완전 외부 결합

### 자기 결합

생성되는 결과를 기준으로 분류하는 것이 아니라 연산의 대상으로 무엇을 사용하는지에 따른 분유이다. 자기 결합은 ‘자기결합 + 크로스 결합’, ‘자기 결합 + 외부 결합’ 으로 가능하다.

## 19장 : 결합 알고리즘과 성능

옵티마이저가 선택 가능합 결합 알고리즘 크게 3개

- Nested Loops
- Hash
- Sort Merge

옵티 마이저가 어떤 알고리즘을 선택할지 여부는 데이터 크기 또는 결합 키의 부산이라는 요인에 의존한다. 그중 NestedLoop가 각종 결합 알고리즘의 기본이 된다. 그다음이 Hash, Sorted Merge이다.

근데 각 DBMS마다 지원하는 알고리즘이 바뀔 수 있으므로 최신 동향에는 주의를 기울이다.

### Nested Loops

본질적으로 이중반복과 같은 의미이다

1. 결합 대상 테이블에서 레코드를 하나씩 반복해 가며 스캔한다.  이 테이블이 구동테이블, 외부 테이블이다. 다른 테이블이 내부 테이블이다.
2. 구동 테이블 레코드 하나마다 내부 테이블의 레코드를 하나씩 스캔해서 결합 조건에 맞으면 리턴한다.
3. 이러한 작동을 구동 테이블의 모든 레코드에 반복한다.

- 접근되는 레코드 수는 R(A) * R(B)가 된다.
- 한 번의 단계에서 처리하는 레코드 수가 적어 Hash, sort merge에 비해 메모리 소비가 적다
- 모든 DBMS지원

구동 테이블이 작을수록 Nested Loops의 성능이 좋아진다.

이준 반복의 외측과 내측이 반복 처리가 비대칭이다.

왜 구동 테이블이 작을수록 성능적으로 좋을까?

내부테이블의 결합 키 필드에 인덱스가 존재한다는 전제를 기반으로 한다.

만약 테이블의 결합 키 필드에 인덱스가 존재하면 해당 인덱스를 통해 DBMS는 내부테이블을 완전히 순회 하지 않고 내부 반복을 어느정도 건너 뛸수 있게 해준다.

⇒ 즉 내부 테이블의 결합 키 인덱스가 사용되지 않으면 구동 테이블이 작아봤자 아무런 장점이 없다.

하지만 결합 키가 내부테이블에 유일하지 않은 경우 인덱스로 내부테이블에 접근하는 경우라도 여러개의 레코드가 히트되어 해당 부분을 반복해야한다.

따라서 SQL 튜닝의 기본은

‘ 구동 테이블이 작은 Nested Loops ‘ + ‘내부 테이블의 결합 키에 인덱스 ‘

⇒ 어떤 결합 키에 인덱스를 작성해야하는지 초기단계부터 고민해야한다.

하지만 앞서 설명한 결합키가 내부 테이블에 대해 유일하지 않는 경우 성능 저하가 발생할 수 있다. 이런경우 반복 해야하는 수가 늘어지기에 발생한다.

해결방법

1. 구동테이블로 큰테이블을 선택하게 하여 항상 하나의 레코드로 접근하는 것을 보장되게 한다.
2. 해시알고리즘

### Hash 알고리즘

1. 일단 작은 테이블을 스캔 하고 결합키에 해시함수를 적용해서 해시값으로 확인한다.
2. 다른 테이블(큰 테이블)을 스캔하고 결합 키가 해시값에 존재하는지를 확인한다.

해시테이블이 워킹 메모리에 저장되기에 작은 테이블을 선택하는 것이 효율적이다.

Hash를 사용하는 경우는 두 테이블의 크기가 별로 차이나지 않는 경우 선택하는것이 좋다.

특징

- 결합 테이블로부터 해시테이블을 만들어 NL에 비해 메모리 소비가 크다
    - OLTP(사용자 요구에 시스템이 곧바로 응답해야 하는 처리)에서는 사용하면 안된다. (지연이 발생함)
    - 따라서 동시 처리가 적은 간 배티 또는 BI/DWH와 같은 시스템에 한해 사용하는 것이 기본적략이다.
- 메모리 부족시 저장소(하드디스크)를 사용해 지연이 발생한다.
- 출력되는 해시값은 등치 결합에만 사용할 수 있다(입력값의 순서를 알지 못함)
- 양쪽 테이블의 레코드를 전부 읽어야 하므로 테이블의 규모가 크다면 풀스캔 시간을 고려해야한다.

유용한 경우

- NL에서 적절한 구동 테이블이 존재하지 않는 경우
- 앞선 NL의 단점에서 본것처럼 구동 테이블로 사용할만한 작은 테이블은 있지만 내부테이블에서 히트되는 레코드수가 많은 경우
- NL의 내부 테이블에 인덱스가 존재하지 않거나 추가하기 어려운 경우
- 즉 Nested Loops가 효율적으로 작동하지 않는 경우

### Sort Merge

- Nl, Hash가 모두 불가능한 경우
- Sort merge는 결합 대상 테이블들을 각각 결합 키로 정렬하고 일치하는 결합키를 찾으면 결합한다.
1. 대상 테이블을 모두 정렬 해야하기에 Nl보다 많은 메모리를 소비, Hash는 한쪽만 해시테이블을 만들어서 Hash보다 많은 메모리를 사용하기도 한다. 메모리 부족으로 Temp탈락이 발생하면 I/O비용이 늘어나 지연이 발생할 위험도 있다.
2. <, > ,≤ ≥ 모두에 사용가능 하지만 부정 조건(<>)결합에서는 사용할 수 없다.
3. 테이블키로 정렬되어있다면 정렬을 생략할 수 있지만 레코드의 물리적위치를 알고있어야 할때이다. 구현 의존적이다. (구현을 그렇게 한 경우)
4. 테이블을 정렬 하므로 한쪽테이블을 모두 스캔한 시점에 결합을 완료할 수 있다.

유효한 경우

- 테이블 정렬에 많은 시간과 리소스를 요구할 가능성이 있다. 결합 자체에 걸리는 시간은 나쁘지않다.
- ⇒ 그냥 Nl , hash를 먼저 고려해라

### 의도하지 않은 크로스 결합

- 삼각결합의 경우 나타난다.

```sql
SELECT A.col_a B.col_b C.col_c
	FROM Table_A A
		INNER JOIN Table_B B
			ON A.col_a = B.col_b
		INNER JOIN Table_C C
			ON A.col_a = C.col_c
```

Table_b - Table_c에 결합 조건이 존재하지 않는다.

- NL이 선택되는 경우 ⇒ 문제될건 없다.
- 크로스 결합이 선택되는 경우
    - Table B, Table C를 먼저 결합하고 TableA를 결합하는 순서로 수행된다.
    - 이런경우 크로스 결합을 수행하여 비 효율적이다.
    - 왜 크로스 결합이 선택될까?
        - 테이블의 크기에 의해 선택된것을 예상

회피하는 방법

1. 결합 조건이 존재하지 않는 테이블 사이에 불필요한 결합 조건을 추가햊누다.

```sql
SELECT A.col_a B.col_b C.col_c
	FROM Table_A A
		INNER JOIN Table_B B
			ON A.col_a = B.col_b
		INNER JOIN Table_C C
			ON A.col_a = C.col_c
			AND C.col_c = B.col_b; --table b, table c의 결합 조건 추가 이렇게 하여 크로스 결합이 회피될 수 있다.
```

### 20장 결합이 느리다면?

1. 상황에 따르 최적의 결합 알고리즘을 선택

   소규모 - 소규모

   어떤 알고리즘은 선택해도 괜찮

   소규모 - 대규모

   NL, 인덱스 만들기

   하지만 내부테이블의 결합대상 레코드가 많으면 구동테이블과 내부테이블을 바꾸거나 Hahs를 사용할것을 권장

   대규모 - 대규모

   일단 해시 , 결합 키로 정렬되어있다면 SortMerge

   기본 NL, 배치/BI/DWH Hash, Hash사용시에는 Temp탈락에 주의

   NL : ‘작은 구동 테이블’ + ‘내부 테이블의 인덱스’

2. 실행 계획 제어

   어떻게 제어하지? (235P)

    - Oracle
        - 힌트 구
    - PostGresSql
        - hint
    - mysql
        - nestedLoop만 지원

실행계획을 사용자가 제어할 때의 리스크

- 이를 제어하기 위해 나온것이 성능 비용기반에 따른 동적 실행 계획이다.
1. 흔들리는 실행 계획
    1. 실행계획을 옵티마이저에게 맡겨도 최적이 되지 않는 경우가 있다.
    2. 데이터 양의 증가 등에 따라 통계정보가 변했을때 일정한 역치를 넘으면 옵티마이저가 실행계획을 변화시키면서 일어난다. 사전에 예측하기 어렵고 돌발적인 슬로다운을 일으킨다.


SQL의 성능 변동 위험을 줄이려면 되도록 결합을 피해야한다.

비정규화하라는 것인가? ⇒ 다른 대체 수단을 사용하는 방법이 있다 (책의 후반부)
# 결합

## 6.1 기능적 관점으로 구분하는 결합의 종류

크로스 결합, 내부 결합, 외부 결합은 기능적인 관점으로 구분하는 결합의 종류이다.
이들은 생성되는 결과의 형태에 따라 구분되며 베타적인 분류이기에 '내부결합이면서 크로그 결합이다'는 불가능하다.

등가 결합, 비등가 결합은 조인 조건에 따라 구분되는 결합의 종류이다.

자연 결합은 조인 조건이 없는 결합의 종류이다. 암묵적으로 같은 이름의 필드가 등호로 결합된다. 모든 DBMS에서 사용할 수 있지만 사용을 권장하지 않는다.

### 6.1.1 크로스 결합 - 모든 결합의 모체

크로스 결합은 실무에서 사용하지는 않지만 결합의 기본이 되는 결합이다.

크로스 결합은 두 테이블의 모든 레코드를 결합한다. 따라서 크로스 결합을 수행하면 두 테이블의 레코드 수를 곱한 수만큼의 결과가 생성된다. 예를 들어,
```sql
SELECT * FROM A CROSS JOIN B;
```
이라는 SQL을 실행하면 A 테이블의 레코드 수가 10개, B 테이블의 레코드 수가 5개라면 결과는 50개의 레코드가 생성된다.

크로스 결합이 실무에서 사용되지 않는 이유는 두 가지이다.
1. 결과가 너무 많아서 처리하기 어렵다.
2. 비용이 매우 크다.

#### 실수로 사용할 수 있는 경우
```sql
SELECT * FROM A, B;
```
이라는 SQL을 실행하면 크로스 결합이 수행된다. 결합 조건이 없기 때문에 DBMS는 두 개의 테이블에서 나올 수 있는 모든 조합을 만든다.

따라서 표준을 잘 지키는 것이 중요하다. 

### 6.1.2 내부 결합 - 내부라는 말을 사용하는 이유

내부 결합은 가장 많이 사용되는 결합이다.

내부 결합의 결과는 반드시 크로스 결합의 부분 집합이다. 가장 쉽게 내부 결합을 만드는 방법은 크로스 결합으로 결과를 내고 조건으로 필터링하는 것이다.

#### 내부 결합과 같은 기능을 하는 상관 서브쿼리
```sql
SELECT E.employee_id, E.employee_name, D.id,
       (SELECT department_name FROM department D WHERE D.id = E.department_id) AS department_name
FROM employee E;
```
이와 같이 서브쿼리에서 기본 키로 조인을 사용하면 스칼라 서브쿼리 즉, 리턴값이 하나의 단일 값인 쿼리가 된다. 이는 내부 결합과 같은 결과를 생성한다.

하지만 비용이 꽤 높은 편이다. 이유는 서브쿼리가 레코드 수만큼 실행되기 때문이다.

### 6.1.3 외부 결합 - 외부라는 말을 사용하는 이유

외부 결합은 크로스 결합의 부분 집합일 수도 있고 그렇지 않을 수도 있다.

외부 결합은 다음과 같이 세 종류가 있다.
1. 왼쪽 외부 결합
2. 오른쪽 외부 결합
3. 완전 외부 결합

왼쪽 외부 결합과 오른쪽 외부 결합은 완전히 같은 기능을 수행하며 마스터가 되는 테이블의 위치를 어디에 두느냐의 차이이다.

외부 결합의 크로스 결합에 없는 행을 만들어낼 수 있는데 이를 `NULL`로 채운다. 이는 외부 결합이 마스터 테이블의 정보를 모두 보존하고자 `NULL`을 생성하기 때문이다.
반면, 크로스 결합과 내부 결합은 `NULL`을 생성하지 않는다.

### 6.1.4 자기 결합 - 자기란 누구일까

자기 결합은 말 그대로 자기 자신과 결합하는 것이다. 자기 결합은 '자기 결합 + 크로스 결합', '자기 결합 + 내부 겨합' 과 같이 조합할 수 있다.

자기 결합을 수행하는 경우 일반적으로 같은 테이블에 별칭을 붙여 다른 테이블인 것 처럼 다룬다.

## 6.2 결합 알고리즘과 성능

옵티마이저가 선택 가능한 결합 알고리즘은 크게 세 가지이다.
1. Nested Loops
2. Hash 
3. Sort-Merge

옵티마이저가 어떤 알고리즘을 선택할 지 여부는 데이터 크기 또는 결합 키의 분산이라는 요인에 의존한다.

대부분의 DBMS가 세 알고리즘을 모두 지원하지만 MySQL은 Nested Loops와 그 파생 버전만 지원한다.

### 6.2.1 Nested Loops

#### 작동 방식
Nested Loops는 두 테이블 중 하나의 테이블을 기준으로 다른 테이블을 순회하면서 조인을 수행하는 알고리즘이다.

Nested Loop는 다음과 같은 특징이 있다.
1. A,B 결합 대상 레코드 수를 R(A), R(B)라고 하면, 접근되는 레코드 수는 R(A) * R(B)가 된다. Nested Loops의 실행 시간은 이 레코드 수에 비례한다.
2. 한 번의 단계에서 처리하는 레코드 수가 적으므로 Hash 또는 Sort merge에 비해 메모리 소비가 적다.
3. 모든 DBMS에서 지원한다.

여기서 성능은 구동 테이블을 어떤 것을 선택하느냐에 따라 달라진다. 일반적으로 구동 테이블이 작을수록 성능이 좋아진다. 여기서 중요한 것은 이중 반복의 외측과 내측의 반복 처리가 비대칭이라는 것이다.

#### 구동 테이블 
구동 테이블이 작을 때 성능이 좋아지는 것에는 한 가지 전제가 있다. 바로 `내부 테이블의 결합 키 필드에 인덱스가 존재`이다.

만약 내부 테이블의 결합 키 필드에 인덱스가 존재한다면 해당 인덱스를 통해 DBMS는 내부 테이블을 완전히 순환하지 않아도 된다. 즉, 내부 테이블의 반복을 어느 정도 건너뛸 수 있다는 것이다.
최선의 경우 접근하는 레코드 수가 R(A) * 2가 되기도 한다.

구동 테이블은 실행 계획에서 같은 들여쓰기 레벨에 있어서 위에 위치하는 테이블이다.

만약 구동 테이블이 결합 키에 인덱스가 없다면 구동 테이블이 작아봤자 아무 의미가 없어진다.

내부 테이블의 반복을 완전하게 생략할 수 있는 경우는 결합 키가 내부 테이블에 대해 유일한 경우이다. 이 때, 등치 결합이라면 내부 테이블의 접근 대상 레코드를 한 개로 한정할 수 있어서 이중 반복의 내측에 있는 반복을 완전히 생략할 수 있다.

따라서 `구동 테이블을 작게`라는 말보다는 `내부 테이블을 크게`라는 말이 더욱 적절하다.

#### Nested Loops의 단점

결합 키가 내부 테이블에 대해 유일하지 않는 경우, Nested Loops의 성능은 크게 저하될 수 있다. 결합 키로 내부 테이블에 접근할 때 히트되는 레코드가 많아지면 내부 테이블에 대한 반복횟수가 높아지기 때문이다.

이런 경우, 오히려 구동 테이블을 크게 하는 것이 성능을 높일 수 있다.

### 6.2.2 Hash

#### 작동 방식

해시 결합은 작은 테이블을 스캔하고 결합 키에 해시 함수를 적용해서 해시값으로 변환한다. 그 후, 큰 테이블을 스캔하고 결합 키가 해시값에 존재하는지를 확인한다.

작은 테이블에서 해시 테이블을 만드는 이유는 해시 테이블은 DBMS의 워킹 메모리에 저장되므로 조금이라도 작은 것이 효율적이기 때문이다.

해시 결합은 다음과 같은 특징이 있다.

1. 결합 테이블로부터 해시 테이블을 만들어서 활용하므로 메모리 소비가 크다.
2. 메모리가 부족하면 저장소를 사용하여 지연이 발생할 수 있다.
3. 입력값의 순서를 알지 못하므로 등치 결합에만 사용할 수 있다.

해시 결합이 유용한 경우는 다음과 같다.

1. 큰 테이블과 작은 테이블의 크기가 비슷한 경우
2. 구동 테이블이 확실하지만 내부 테이블에서 히트되는 레코드 수가 많은 경우
3. Nested Loops의 내부 테이블에 인덱스가 존재하지 않는 경우

이는 즉 Nested Loops가 효율적이지 못한 경우의 차선책이 해시라는 것이다.

### 6.2.3 Sort-Merge

#### 작동 방식

Sort-Merge는 결합 대상 테이블들의 결합 키로 정렬하고 일치하는 결합 키를 찾아서 결합한다.

상당히 예외적인 테이블 정렬을 생략할 수 있는 경우에 사용한다.

### 6.2.4 의도치 않은 크로스 결합

의도치 않게 크로스 결합이 발생하는 경우를 `삼각 패턴`이라고 부른다.

A,B,C의 테이블이 A-B-C의 연결관계가 있고 A와 C는 연결되어 있지 않은 경우, 만약 A와 C 중에 크기가 작은 이유로 구동 테이블로 선택된다면 
A와 B의 크로스 결합이 발생하게 된다.

이런 경우, 옵티마이저가 삼각 패턴을 인지하지 못하고 크로스 결합을 수행하게 된다.

이를 회피하기 위해서는 결합 조건이 존재하지 않는 테이블 사이에 불필요한 결합 조건을 추가해주어야 한다.


# 3. SQL의 조건 분기

# 3.1 UNION을 사용한 쓸데없이 긴 표현

- UNION을 사용한 조건 분기는 WHERE 구만 조금씩 다른 여러 개의 SELECT 구문을 합쳐서, 복수의 조건에 일치하는 하나의 결과 집합을 얻고 싶을 때 사용한다.
- 이런 방법은 성능적인 측면에서 굉장히 큰 단점을 가지고 있다.
- 외부적으로 하나의 SQL 구문을 실행하는 것처럼 보이지만, 내부적으로는 여러 개의 SELECT 구문을 실행하는 실행 계획으로 해석되기 때문이다.
- 따라서 테이블에 접근하는 횟수가 많아져서 I/O 비용이 크게 늘어난다. - 신중히 검토하자.

## 3.1.1 UNION을 사용한 존건 분기와 관련된 간단한 예제

- UNION을 사용한 조건 분기

```sql
SELECT item_name, year, price_tax_ex AS price
	FROM Items
 WHERE year <= 2001
UNION ALL
SELECT item_name, year, price_tax_in AS price
	FROM Items
 WHERE year >= 2002;
```

- 조건이 배타적이므로 중복된 레코드가 발생하지 않습니다.
- 문제점
    1. 쓸데없이 길다. 두 개의 쿼리를 두 번이나 실행하고 있다.
    2. 성능

### UNION을 사용했을 때의 실행 계획 문제

- UNION 쿼리는 Items 테이블에 2회 접근한다.
- 그리고 그때마다 TABLE ACCESS FULL이 바생하므로, 읽어들이는 비용도 테이블의 크기에 따라 선형으로 증가하게 된다.
- 테이블의 크기가 커지면 캐시 히트율이 낮아지므로 그러한 것도 기대하기 힘들어진다.

### 정확한 판단 없는 UNION 사용 회피

- 정확한 판단 없이 SELECT 구문 전체를 여러 번 사용해서 코드를 길게 만드는 것은 쓸데없는 테이블 접근을 발생시키며 SQL의 성능을 나쁘게 만든다.
- 또한 물리 자원(저장소의 I/O 비용)도 쓸데없이 소비하게 된다.

## 3.1.2 WHERE 구에서 조건 분기를 하는 사람은 초보자

- 조건 분기를 WHERE 구로 하는 사람들은 초보자다.
- 잘 하는 사람은 SELECT 구만으로 조건 분기를 한다.
- SELECT 구문에서 CASE 식을 사용한 조건 분기

```sql
SELECT item_name, year,
			 CASE WHEN year <= 2001 THEN price_tax_ex
						WHEN year >= 2002 THEN price_tax_in END AS price
	FROM Items;
```

이 쿼리도 UNION을 사용한 쿼리와 같은 결과를 출력한다. `성능적으로 이번 쿼리가 훨씬 좋다.`

## 3.1.3 SELECT 구를 사용한 조건 분기의 실행 계획

- Items 테이블에 대한 접근이 2회 → 1회로 줄어든다.
- UNION을 사용한 구문보다 성능이 2배 좋아졌다. SQL 구문 자체의 가독성 향상
- UNION을 사용한 분기는 SELECT ‘구문’을 기본 단위로 분기하고 있다.
    - 구문을 기본 단위로 사용하고 있다는 점에서, 아직 절차 지향형의 발상을 벗어나지 못한 방법이라고 말할 수 있다.
- 반면 CASE 식을 사용한 분기는 문자 그대로 ‘식’을 바탕으로 하는 사고다.
    - ‘구문’에서 ‘식’으로 사고를 변경하는 것이 SQL을 마스터하는 열쇠 중 하나다.

# 3.2 집계와 조건 분기

## 3.2.1 집계 대상으로 조건 분기

### UNION을 사용한 방법

- 이 문제를 풀 때 절차 지향적인 사고방식을 가진다면?
    - 남성의 인구를 지역별로 구하고
    - 여성의 인구를 지역별로 구한 뒤 머지(merge)하는 방법
- 테이블에 풀 스캔이 2회 수행된다.

### 집계의 조건 분기도 CASE 식을 사용

```sql
SELECT prefecture,
			 SUM(CASE WHEN sex = '1' THEN pop ELSE 0 END) AS pop_men,
			 SUM(CASE WHEN sex = '2' THEN pop ELSE 0 END) AS pop_wom,
	FROM Population
 GROUP BY prefecture;
```

### CASE식의 실행 계획

- 테이블 풀 스캔 2회 → 1회로 감소.
- 성능적으로 큰 힘을 발휘한다.

## 3.2.2 집약 결과로 조건 분기

- 직원과 직원이 소속된 팀을 관리하는 테이블
    1. 소속된 팀이 1개라면 해당 직원은 팀의 이름을 그대로 출력
    2. 소속된 팀이 2개라면 해당 직원은 ‘2개를 겸무’라는 문자열을 출력
    3. 소속된 팀이 3개 이상이라면 해당 직원은 ‘3개 이상을 겸무’라는 문자열을 출력

### CASE 식을 사용한 조건 분기

```sql
SELECT emp_name,
				CASE WHEN COUNT(*) = 1 THEN MAX(team)
						 WHEN COUNT(*) = 2 THEN '2개를 겸무'
						 WHEN COUNT(*) >= 3 THEN '3개 이상을 겸무'
					END AS team
	FROM Employees
 GROUP BY emp_name;
```

# 3.3 그래도 UNION이 필요한 경우

- UNION을 사용하지 않으면 안 되는 경우도 있다.
- 또한 UNION을 사용하는 것이 오히려 성능적으로 좋은 경우도 있다.

## 3.3.1 UNION을 사용할 수 밖에 없는 경우

- 머지 대상이 되는 SELECT 구문들에서 사용하는 테이블이 다른 경우가 대표적이다.
- 쉽게 말하면 여러 개의 테이블에서 검색한 결과를 머지하는 경우

```sql
SELECT col_1
	FROM Table_A
 WHERE col_2 = 'A'
UNION ALL
SELECT col_3
	FROM Table_B
 WHERE col_4 = 'B';
```

- CASE 식을 사용할 수 없다는 것은 아니다.
- 하지만 그렇게 하면 필요 없는 결합이 발생해서 성능적으로 악영향이 발생한다.
- 따라서 실행 계획 등을 확인해서 어떤 것이 더 좋은지 명확하게 확인해줘야 한다.

## 3.3.2 UNION을 사용하는 것이 성능적으로 더 좋은 경우

- UNION을 사용했을 때 좋은 인덱스(압축을 잘 하는 인덱스)를 사용한다.
- 이외의 경우에는 테이블 풀 스캔이 발생한다면, UNION을 사용한 방법이 성능적으로 더 좋을 수 있다.
    - OR, IN을 사용하면 테이블 풀 스캔 발생

# 3.4 절차 지향형과 선언형

- 예외적인 몇 가지 상황을 제외하면 UNION을 사용하지 않는 것이 성능적으로도 좋고 가독성도 좋다는 것이다.
- 원래 UNION이 조건 분기를 위해 만들어진 것이 아니므로 당연한 결과다.
- CASE식은 조건 분기를 위해 만들어졌으므로, CASE 식을 사용하는 것이 자연스럽다.

## 3.4.1 구문 기반과 식 기반

- SQL의 기본적인 체계는 선언형이다.
- ‘구문’이 아니라 `식`이다.
- 절차 지향형 언어가 CASE `구문`으로 분기하는 것을, SQL은 CASE `식`으로 분기한다.
- SQL 구문의 각 부분(SELECT, FROM, WHERE, GROUP BY, HAVING, ORDER BY)에 작성하는 것은 모두 식이다.

## 3.4.2 선언형의 세계로 도약

- 절차 지향형 세계에서 선언형 세계로 도약하는 것이 곧 SQL 능령 향상의 핵심이다.
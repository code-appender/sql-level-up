# 1장 : DBMS 아키텍처 개요

## DBMS 내부의 기능

1. 쿼리 평가 엔진
   → 핵심!
   입력 받은 엔진은 사용자로 부터 입력받은 sql 구문을 분석하고 어떤 순서로 기억장치의 데이터에 접근할지를 결정합니다. 이때 결정 되는 계획을 실행 계획이라 부른다.
   이 책에서 중요하게 이야기하는 성능과도 깊은 관련이 있는 모듈이다.
2. 버퍼 매니저
3. 디스크 용량 매니저
4. 트랜잭션 매니저와 락 매니저
5. 리커버리 매니저

## DBMS와 기억장치의 관계

### HDD

- 현재 대부분의 dbms는 HDD에 저장한다.
- 2차 기억장치
- 좋은 장점도 나쁜 단점도 없는 매체

### 메모리

- 디스크에 비해 기억 비용이 비싸ㅈ다.
- 데이터 베이스 내부 데이터를 모두 메모리에 올리는것을 불가능 하다.

### 버퍼를 활용한 속도 향상

- DBMS가 일부라도 데이터를 메모리에 올려 성능향상을 한다.
- 자주 사용하는 데이터는 메모리에 올려 빠르게 접근한다.
- 메모리에 데이터를 저장해 디스크의 접근을 줄이고 이렇게 하여 I/O 시간을 줄인다.
- 이렇게 성능향상을 목적으로 데이터를 저장하는 메모리를 버퍼, 캐시라고 부른다.
- 이 책에서는 버퍼 == 캐시로 사용한다.

### 메모리의 두개의 버퍼

데이터를 유지하기 위해 사용하는 메모리 종류

- 데이터 캐시
    - 디스크에 있는 데이터의 일부를 메모리에 유지하기 위해 사용하는메모리 영역
    - 만약 데이터 캐시에 데이터가 저장되어있다면 디스크에 접근하지 않아도 된다
    - 데이터 베이스 세계에는 ‘디스크를 건드리는 자는 불행해진다’ 라는 오래된 격언이 있다.
- 로그버퍼
    - 갱신처리와 (insert, delete, update, merge)와 관련이 있다.
    - dbms는 갱신과 관련된 sql 구문을 사용자로부터 받으면 바로 데이터를 변경하지 않고 로그버퍼위에 변경정보를 보내고 이후 디스크 변경을 수행한다.
        - 왜 이렇게 하는가
          ⇒ 성능을 높이기 위해서
          저장소는 검색 뿐만 아니라 갱신을 할때도 상당한 시간이 소모된다. 따라서 한 번 메모리에 갱신정보를 받은 시점에 사용자에게는 sql 구문의 실행이 끝났다 하고 내부적으로 관련된 일을 처리한다.
    - 데이터 베이스의 갱신처리는 sql구문의 실행 시점과 저장소에 갱신하는 시점에 차이가 있는 비동기 처리이다.

하지만 결국 DBMS는 저장소의 느림을 어떻게 보완할것인가 라는 것을 계속해서 고민해온 미들웨어 이다.

만약 빨랐다면 이런 귀찮은 구조를 사용하지 않아도 됐을것이다.

## 메모리 사용시의 트레이드 오프

메모리 사용시의 추가적인 단점

### 휘발성

영속적이지 않다.

미래에 메모리가 싸져도 대체할 수 없다.

가장 큰 단점들

- 장애 발생시 메모리에 있던 데이터가 모두 사라져버려 데이터 부정합을 발생 시킨다. 하지만 실제 데이터는 디스크에 있어서 다시 읽어들이면 된다. 따라서 휘발성이 중요하다.
- 하지만 로그파일은 메모링 위에 있다 이때문에 문제가 발생할 수도 있다.
    - 이를 해결하기 위해 DBMS는 커밋시점에 갱신정보를 로그파일에 씀으로써 장애가 발생해도 정합성을 유지할 수 있게한다. 커밋이란 갱신처리를 확정한다. DBMS는 커밋된 데이터를 영속화 한다.
    - 반대로 말하면 커밋때는 반드시 디스크에 동기 접근이 일어나고 결국 여기서 지연이 발생할 가능성이 있다.
        - 동기처리 : 정합성 O, 성능 X
        - 비동기처리 : 정합성 X, 성능 O

### 로그버퍼의 사이즈가 왜 더 작을까?

- 더 작아서 문제가 될지는 성능검증을 해보기 전까지는 알 수가 없다
- 보통 DB는 기본적으로 검색을 메인으로 처리한다고 가정한다.
- 갱신처리에 값 비싼 메모리를 많이 사용하는것보다는 자주 검색하는 데이터를 캐시에 올리는게 더 좋다고 생각하는것
- 실제 많은 DBMS가 물리메모리에 여유가 있다면 데이터 캐시를 많이 할당할것을 추천한다.
- 만약 갱신이 더 많은 시스템의 경우는 튜닝을 통해서 로그버퍼의 크기를 키우는 등의 역할을 해야한다.

### 검색 vs 갱신

적절한 판단을 통해 튜닝해야한다.

만약 로그 버퍼가 크게 잡혀있다면 갱신처리와 관련해 큰 부하가 걸릴것을 고려한 설계임을 알 수 있고 캐시버퍼가 크게 되어있다면 검색 처리와 관련된 처리가 중심이라는것을 알 수 있다.

## 워킹 메모리

앞선 2개의 메모리 영역외의 일반적 메모리 영역을 하나 더 가지고 있다.

정렬 또는 해시 관련 처리에 사용되는 영역으로 워킹메모리라 부르며 정렬은 order by 구, 집합 연산, 윈도우 함수 등에 사용되면 해시는 테이블등의 결합에서 해시 결합이 사용되는 때 실행됩니다.

이 영역이 중요한 이유는 만약 이 영역이 다루려는 데이터양보다 작아 부족해지는 경우가 생기면 대부분의 DBMS가 저장소를 사용하기 떄문이다. (메모리가 부족하면 디스크를 사용)

→ 부족하면 무슨일이 일어날까?

속도가 느려진다.(갑자기 느려지는 순간적인 변화가 일어난다)

여러개의 sql 구문을 동시에 실행하면 메모리가 넘칠 수 있다. 부하검사를 진행하여 메모리 부족이 있는지 판단하기 전까지는 알기 힘들다.

DBMS는 메모리가 부족하다고 해서 죽지는 않는다 어떻게든 하려 한다.

## DBMS와 실행 계획

### sql 언어의 특징

절차적 언어는 데이터를 어떻게 접근할지 HOW를 책임지고 기술한다.

비절착적 언어인 RDB는  WHAT을 기술하는것으로 축소되었다.

→ 왜 ? 비즈니스 전체의 생산성 향상을 위해서

→ 하지만 성능문제를 고민하여 내부절차를 확인해야한다.

## 데이터 베이스 접근방식

### 파서

쿼리를 파싱한다.

데이터 베이스의 이름, 컬럼과 같은 처음에 잘못된 오류를 미리 걸러낸다.

sql구문을 정형적인 형식으로 변환해준다.

### 옵티 마이저

접근법을 최적화한다.

실행 계획을 작성하고, 비용을 연산한다.

### 카탈로그 매니저

DBMS의 내부정보를 모아놓은 테이블들로 테이블또는 인덱스의 통계정보가 저장되어있다.

데이터 베이스 엔지니어가 항상 신경써줘야 하는 부분

카탈로그 내에는 테이블의 레코드수, 필드수 필드크기 , 필드의 카디널리티, 분포정도, NULL수, 인덱스 정보등을 가직 있고 옵티마이저가 실행계획을 작성한다.

이 때문에 카탈로그의 내용이 갱신되지 못한 경우는 이전의 정보를 바탕으로 최적의 계획을 세워 최적의 플랜을 기대할 수 없다.

이 때문에 올바른 통계정보가 모이는것은 중요하다. 수동갱신 뿐만 아니라 데이터를 크게 갱신하는 배치 처리가 있는경우 JobNet을 조합하는 경우도 많다.

### 플랜평가

성능이 좋지 않은 SQL 구문이 있을때 실행계획을 읽고 수정방안등을 고려할 수 있다.

## 실행 계획이 SQL 구문의 성능을 결정

데이터 양이 많은 테이블에 접근하거나 복잡한 SQL 구문을 실행하면 반응 지연이 발생하는 경우가 있다.

### 실행 계획 확인 방법

각각의 명령어를 통해 확인할 수 있다.

postgresql → EXPLAIN , Oracle → set autotrace traceonly

- 실행 계획에 포함되는 내용
    - 조작 대상 객체
    - 객체에 대한 조작 종류
    - 조작 대상이 되는 레코드 수

실행 계획에 포함된 실행시간, 실행비용은 절대 평가의 지표로 쓰는것은 곤란하다. 추정값은 절대 지표로 사용하면 안된다. 구현에 따라서 실제 실행 시간을 출력하는 경우도 있다. (메뉴얼 참고)

예시

```sql
Select * 
    from shops
    where shot_id = '00050';
```

- 조작 대상 레코드 수 
  - 1개 , where에서 지정해서 접근대상은 반드시 하나의 레코드

- 접근대상 객체와 조작
  - 인덱스 스캔 : 모집합 레코드 수에서 선택되는 레코드 수가 적다면 풀스캔 보다 빠르게 접근을 수행한다. 풀스캔은 데이터 양에 비례해서 처리비용이 늘어나지만 인덱스 사용시에는 B-tree가 모집합의 데이터양에 비해 대수함수적 으로 처리비용이 늘어나기 때문이다.

### 테이블 결합의 실행계획

- nested loops 
  - 한 쪽 테이블을 읽으면서 레코드 하나마다 결합 조건에 맞는 레코드를 다른 쪽 테이블에서 찾는 방식이다. 절차지향적 구현시 이중반복 이여서 중첩반복 이라는 이름이 붙었다.

- sort merge

  - 결합 키(ID)로 레코드를 정렬하고 순차적으로 두개의 테이블을 결합한다.

  - 결합 전 전처리로 정렬을 수행하고 워킹메모리에서 다루었던 워킹메모리를 사용한다.

- Hash

  - 결합 키값을 해시값으로 맵핑하는 방법, 작업용 메모리 영역을 사용한다.

### 실행계획을 읽는법

트리구조, 중첩단계가 깁을 수록 먼저 실행된다. 위에서 아래로 실행된다.

## 실행 계획의 중요성

최근의 옵티마이저 성능은 우수하다.

하지만 복잡한 문제를 옵티마이적에게 정보를 제대로 주지 못하는 문제가 발생하는경우와 같은 상황에서는 성능이 좋지 않다.

이런경우 수동으로 실행계획을 변경할 수 있다.

<aside>
💡 컬럼

DBMS의 Sql Server는 메모리를 자동으로 조정한다. 윈도우와 SqlServer를 같은 벤더(마이크로소프트)가 개발해서, 두 개를 밀접하게 연계할 수 있기 때문이다.
</aside>
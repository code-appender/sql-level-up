# 1. DBMS 아키텍처

# DBMS 아키텍처 개요

- 쿼리 평가 엔진
    - 입력받은 SQL 구문을 분석하고, 어떤 순서로 기억장치의 데이터를 접근할지를 결정한다.
- 버퍼 매니저
    - DBMS는 버퍼라는 특별한 용도로 사용하는 메모리 영역을 확보한다.
- 디스크 용량 매니저
    - 어디에 어떻게 데이터를 저장할지를 관리하며, 데이터의 읽고 쓰기를 제어한다.
- 트랜잭션 매니저와 락 매니저
    - 트랜잭션의 정합성을 유지하면서 실행시키고, 필요한 경우 데이터에 락을 걸어 다른 사람의 요청을 대기시킨다.
- 리커버리 매니저
    - 데이터를 정기적으로 백업하고 문제가 일어났을 때 복구한다.

# DBMS와 버퍼

## 1. 공짜 밥은 존재할까?

- 많은 데이터를 저장하려 하면 속도를 잃고, 속도를 얻고자 하면 많은 데이터를 영속적으로 저장하기 힘들다는 트레이드오프가 발생한다.

## 2. DBMS와 기억장치의 관계

### 하드디스크(HDD)

- DBMS가 데이터를 저장하는 매체다.

### 메모리

- 비용이 비싸다.
- SQL 구문의 실행 속도가 빠르다.

## 3. 메모리 위에 있는 두 개의 버퍼

DBMS가 데이터를 유지하기 위해 사용하는 메모리는 크게 다음과 같다.

### 데이터 캐시

- 데이터 캐시는 디스크에 있는 데이터의 일부를 메모리에 유지하기 위해 사용하는 메모리 영역.
- 디스크와 같은 저속 저장소에 접근하지 않고 처리가 수행된다. 따라서 굉장히 빠르게 응답함.
- 버퍼에서 데이터를 찾을 수 없다면, 저속 저장소까지 데이터를 가지러 가야 한다.
- SQL 구문의 응답 속도가 느려진다.

### 로그 버퍼

- 로그 버퍼는 갱신처리(INSERT, DELETE, UPDATE, MERGE)와 관련 있다.
- DBMS는 갱신과 관련된 SQL 구문을 사용자로부터 받으면, 곧바로 저장소에있는 데이터를 변경하지 않는다.
- 일단 로그 버퍼 위에 변경 정보를 보내고 이후 디스크에 변경을 수행한다.

## 4. 메모리의 성질이 초래하는 트레이드오프

메모리가 가진 단점은 가격이 비싸서 보유할 수 있는 데이터 양이 적은 것이다.

이 이외에도 몇 가지 단점이 있다.

### 휘발성

- 메모리에는 데이터의 영속성이 없다.
- 하드웨어의 전원을 꺼버리면 메모리 위에 올라가 있는 모든 데이터가 사라진다. → 휘발성
- DBMS를 껐다 키면 버퍼 위의 모든 데이터가 사라진다.
- 결국 메모리 가격이 엄청나게 싸진다고 해도 영속성이 없는 이상 기능적으로 디스크를 완전히 대체하는 것은 불가능하다.

### 휘발성의 문제점

- 가장 큰 문제점은 장애가 발생했을 때 메모리에 있던 데이터가 모두 사라져버려 데이터 부정합을 방생시키는 것이다.
- 해결하기 위해, 동기처리를 통하여 데이터 정합성을 유지한다.

## 5. 시스템 특성에 따른 트레이드오프

### 데이터 캐시와 로그 버퍼의 크기

- 데이터 캐시에 비해 로그 버퍼의 초깃값이 굉장히 작다.
- 데이터베이스가 기본적으로 검색을 메인으로 처리한다고 가정하기 때문이다.
- 검색 → 수백만에서 수천만 건, / 갱신 → 한 건에서 수만 건
- 따라서 갱신 처리에 값비싼 메모리를 많이 사용하는 것보다는, 자주 검색하는 데이터를 캐시에 올려놓는 것이 좋다.

### 검색과 갱신 중에서 중요한 것

- 메모리 할당을 스스로 조정하는 DBMS도 존재하지만, 자동 설정에 의지하는 일은 위험하다.
- 어떤 것을 우선하여 지킬 것인지, 버릴 것인지 판단해야 한다.

## 6. 추가적인 메모리 영억 ‘워킹 메모리’

### 언제 사용될까?

- DBMS는 앞에서 설명했던 2개의 버퍼 이외에도, 일반적으로 메모리 영역을 하나 더 가지고 있다.
    - 이는 정렬 또는 해시 관련 처리에 사용되는 작업용 영역으로 **워킹 메모리**라고 부른다.
- 정렬은 ORDER BY 구, 집합 연산, 윈도우 함수 등의 기능을 사용할 때 실행된다.
- 반면 해시는 주로 테이블 등의 결합에서 해시 결합이 사용되는 때 실행된다.

### 부족하면 무슨 일이 일어날까?

- 저장소는 메모리에 비해서 굉장히 느리기 때문에, 전체적인 속도가 느려진다.
- 메모리가 부족하다고 처리가 멈추거나 에러가 발생하는 것처럼 심각한 문제가 생기는 것은 아니다.

# DBMS와 실행 계획

### 2. 데이터에 접근하는 방법은 어떻게 결정할까?

### 파서(parser)

- 사용자로부터 입력받은 SQL 구문이 항상 구문적으로 올바르다는 보증 검사를 해주는 것.
- SQL 구문을 정형적인 형식으로 변환해준다.

### 옵티마이저(optimizer)

- 한국어로 최적화
- 최적화의 대상은 데이터 접근법(실행 계획)이다. DBMS 두뇌의 핵심.
- 옵티마이저는 인덱스 유무, 데이터 분산 또는 편향 정도, DBMS 내부 매개변수 등의 조건을 고려해서 선택 가능한 많은 실행 계획 작성하고, 이들의 비용을 연산하고, 가장 낮은 비용을 가진 실행 계획을 선택한다.

### 카탈로그 매니저(catalog manager)

- 옵티마이저에 중요한 정보를 제공하는 것이 카탈로그 매니저다.
- 카탈로그란 DBMS의 내부 정보를 모아놓은 테이블들로, 테이블 또는 인덱스의 통계 정보가 저장되어 있다.
- 카탈로그 정보를 간단하게 ‘통계 정보’라고 부른다.

### 플랜 평가(plan evaluation)

- 옵티마이저가 SQL 구문에서 여러 개의 실행 계획을 세운 뒤 그것을 받아 최적의 실행 결과를 선택하는 것이 플랜 평가이다.
- 실행 계획이라는 것은 곧바로 DBMS가 실행할 수 있는 형태의 코드가 아니다. 계획서다.
- 성능이 좋지 않은 SQL 구문이 있을 때 실행 계획을 읽고, 수정 방안 등을 고려할 수 있다.

## 4. 최적의 실행 계획이 작성되게 하려면

- 올바른 통계 정보가 모이는 것은 SQL 성능에 굉장히 중요한 문제다.
- 테이블의 데이터가 바뀌면 카탈로그의 통계 정보도 함께 갱신해야 한다.

# 실행 계획이 SQL 구문의 성능을 결정

## 1. 실행 계획 확인 방법

- MYSQL: EXPLAIN ETENDED SQL 구문

## 2. 테이블 풀 스캔의 실행 계획

- 조작 대상 객체
- 객체에 대한 조작의 종류
- 조작 대상이 되는 레코드 수

## 3. 인덱스 스캔의 실행 계획

```sql
SELECT *
	FROM Shops
	WHERE Shop_id = '00050';
```

### 조작 대상이 되는 레코드 수

- WHERE 구에서 기본 키가 ‘00050’인 점포를 지정했으므로, Rows가 1로 바뀌었다.

### 접근 대상 객체와 조작

- INDEX UNIQUE SCAN이라는 조작이 나타난다.
- 스캔하는 모집합 레코드 수애서 선택되는 레코드 수가 적다면 테이블 풀 스캔보다 빠르게 접근을 수행한다.
- 인덱스를 사용할 때 활용되는 B-tree가 모집합의 데이터양에 따라 대수 함수적으로 처리 비용이 늘어나기 때문이다.
- 간단하게 인덱스의 처리 비용이 완만하게 증가한다는 뜻으로, 특정 데이터양(N)을 손익 분기점으로 인덱스 스캔이 풀 스캔보다도 효율적인 접근을 한다.

## 4. 간단한 테이블 결합의 실행 계획

### Nested Loops

- 한쪽 테이블을 읽으면서 레코드 하나마다 결합 조건에 맞는 레코드를 다른 쪽 테이블에서 찾는 방식이다.

### Sort Merge

- 결합 키로 레코드를 정렬하고, 순차적으로 두 개의 테이블을 결합하는 방법이다.
- 결합 전에 전처리로 정렬을 수행해야 하는데, 작업용 메모리로 ‘워킹 메모리’를 사용한다.

### Hash

- 결합 키값을 해시값으로 맵핑하는 방법이다.
- 해시 테이블을 만들어야 하므로, 마찬가지로 작업용 메모리 영역을 필요로 한다.

# 실행 계획의 중요성

- 옵티마이저는 우수하지만, 완벽한 것은 아니다.
- 옵티마이저가 좋을 것으로 여겨 선택한 실행 계획이 참담한 성능을 만들어내는 경우도 많다.
- 실행 계획을 수동으로 변경해주어야 한다.